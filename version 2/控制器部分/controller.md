
# 一般服务算法

## 低时延算法

输入：路径状态信息(以DataFrame格式，包含int型路径id，int型路径最新时延(ms))。服务时延需求(int型，单位ms)

计算：根据服务时延需求，选择满足需求的最差路径

输出：算法最终确定的路径(int型路径id，若无可选路径，则返回-1)

函数框架：

    def low_delay(path_df, s_delay):
        path_id = -1 # 初始化path_id
        # 计算过程
        return path_id # 返回路径id

## 高带宽算法

输入：路径状态信息(以DataFrame格式，包含int型路径id，int型路径最新剩余带宽(MB)(总带宽-最新吞吐量))。服务带宽需求(int型，单位MB)

计算：根据服务带宽需求，选择满足需求的最差路径

输出：算法最终确定的路径(int型路径id，若无可选路径，则返回-1)

函数框架：

    def high_bandwidth(path_df, s_bandwidth):
        path_id = -1
        # 计算过程
        return path_id

## 高可靠算法

输入：路径状态信息(以DataFrame格式，包含int型路径id，int型路径最新时延(ms)，int型路径最新剩余带宽(MB)(总带宽-最新吞吐量))。服务时延需求(int型，单位ms)，服务带宽需求(int型，单位MB)

计算：根据服务时延与带宽需求，选择满足需求的最差路径

输出：算法最终确定的路径(int型路径id，若无可选路径，则返回-1)

函数框架：

    def high_reliability(path_df, s_delay, s_bandwidth):
        path_id = -1
        # 计算过程
        return path_id

## 算法特别说明

INT周期性从北京到广州、广州到北京发送单向遥测包，接收端将该遥测信息存储在各自的本地设备中。

算法执行前，需从两个省的各自数据库中获取信息

# 算力服务算法

## 算力转发算法

输入：两个算力节点最新剩余算力(int型北京节点剩余算力，int型广州节点剩余算力)。服务算力需求(int型)

计算：根据服务算力需求，选择满足需求的算力节点

输出：算法最终确定的算力节点(int型算力节点id，若无可选路径，则返回-1)

函数框架：

    def calculate(node_bj_cal, node_gz_cal, s_cal):
        node_id = -1
        # 计算过程
        return node_id

## 算法特别说明

算力节点在北京和广州各一个，不考虑未来扩展性。

在数据包转发时，优先选择本地算力节点。当本地算力节点能力不足时，才会考虑外省节点。

算法运行前，需从两个算力节点获取节点算力

算力节点需单独撰写python收包与发包程序。在接收到数据包后，根据数据包算力需求进行本地算力值减小，并在3秒后恢复。